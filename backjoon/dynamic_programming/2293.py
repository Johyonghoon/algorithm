# 2293번 동전 1
# https://www.acmicpc.net/problem/2293

"""
5 2 1

1 : 1
(0, 0, 1)
2 : 2
(0, 0, 2)
(0, 2, 1)
3 : 2
(0, 0, 3)
(0, 1, 1)
4 : 3
(0, 0, 4)
(0, 1, 2) (0, 2, 0)
5 : 4
(0, 0, 5)
(0, 1, 3) (0, 2, 1)
(1, 0, 0)
6 : 5
(0, 0, 6)
(0, 1, 4) (0, 2, 2) (0, 2, 3)
(1, 0, 1)
7 : 6
(0, 0, 7)
(0, 1, 5) (0, 2, 3) (0, 3, 1)
(1, 0, 2) (1, 1, 0)
8 : 7
(0, 0, 8)
(0, 1, 6) (0, 2, 4) (0, 3, 2) (0, 4, 0)
(1, 0, 3) (1, 1, 1)
9 : 8
(0, 0, 9)
(0, 1, 7) (0, 2, 5) (0, 3, 3) (0, 4, 1)
(1, 0, 4) (1, 1, 2) (1, 2, 0)
10 : 10
(0, 0, 10)
(0, 1, 8) (0, 2, 6) (0, 3, 4) (0, 4, 2) (0, 5, 0)
(1, 0, 5) (1, 1, 3) (1, 2, 1) (2, 0, 0)

5가 0개일 때
(0, 0, 10)  1개
(0, 1, 8) (0, 2, 6) (0, 3, 4) (0, 4, 2) (0, 5, 0)   10//2개

5가 1개일 때
(1, 0, 5)  1개
(1, 1, 3) (1, 2, 1)     5//2개

(2, 0, 0)

k % 2 = 0 => +1
k % 5 = 0 => +1
1 1
2 dp[2] * 4 + 1
5 dp[5] + 1

11
5가 0개일 때
1
11 // 2 = 5
5가 1개일 때
1
6 // 2 = 3
5가 2개일 때
1

풀이 참고 후 풀었음
다시 풀어보자
"""


N, K = map(int, input().split())
coins = [int(input()) for _ in range(N)]
dp = [0 for _ in range(K+1)]

for coin in coins:
    for num in range(1, K+1):
        # 자기 자신일 경우 경우의 수 1 증가
        if num == coin:
            dp[num] += 1
        # 자기 자신을 하나 포함하지 않을 경우의 수를 더하기
        elif num > coin:
            dp[num] += dp[num-coin]

print(dp[K])
